package edu.wm.cs.cs301.slidingpuzzle;

import java.util.ArrayList;
import java.util.Arrays;

public class SimplePuzzleState implements PuzzleState {
	
	// set up the fields for the sliding puzzle
	private int[][] board;
	private PuzzleState parent;
	private int pathLength;
	private Operation op;
	
	public SimplePuzzleState(int[][] board) {
		this.board = board;
		this.parent = null;
		this.pathLength = 0;
		this.op = null;
	}
	
	public SimplePuzzleState() {
		
		this.board = null;
		this.parent = null;
		this.pathLength = 0;
		this.op = null;
	}
	
	/** 
	 * this method will set up the start if the puzzle's board
	 * use the dimension and the number of empty slots given by the user to set the board up
	 * to his or her liking
	 **/
	@Override
	public void setToInitialState(int dimension, int numberOfEmptySlots) {
		int count = 1;
		this.board = new int[dimension][dimension];
		for (int i=0; i < dimension; i++) {
			for (int j=0; j < dimension; j++) {
				this.board[i][j] = count;
				count++;
			}
		}
		int cnt = 1;
		while (cnt <= numberOfEmptySlots) {
			this.board[dimension-1][dimension-cnt] = 0;
			cnt++;
		}
	}

	@Override
	public int getValue(int row, int column) {
		return this.board[row][column];
	}

	@Override
	public PuzzleState getParent() {
		return this.parent;
	}

	@Override
	public Operation getOperation() {
		return this.op;
	}

	@Override
	public int getPathLength() {
		return this.pathLength;
	}

	@Override
	public PuzzleState move(int row, int column, Operation op) {
		
		SimplePuzzleState newBoard = new SimplePuzzleState();
		newBoard.board = new int[board.length][board.length];
		for (int i=0; i < board.length; i++) {
			for (int j=0; j < board.length; j++) {
				newBoard.board[i][j] = this.board[i][j];
			}
		}
				
		 switch (op) {
			case MOVERIGHT:
				
				if (isEmpty(row, column+1) == true) {
					newBoard.parent = this;
					newBoard.op = Operation.MOVERIGHT;
					int temp1 = newBoard.board[row][column];
					newBoard.board[row][column] = 0;
					newBoard.board[row][column+1] = temp1;
					newBoard.pathLength = this.pathLength + 1;
					return newBoard;
				}
			case MOVELEFT:
				
				if (isEmpty(row, column-1) == true) {
					newBoard.parent = this;
					newBoard.op = Operation.MOVELEFT;
					int temp2 = newBoard.board[row][column];
					newBoard.board[row][column] = 0;
					newBoard.board[row][column-1] = temp2;
					newBoard.pathLength = this.pathLength + 1;
					return newBoard;
				}
			case MOVEUP:
				
				if (isEmpty(row-1, column) == true) {
					newBoard.parent = this;
					newBoard.op = Operation.MOVEUP;
					int temp3 = newBoard.board[row][column];
					newBoard.board[row][column] = 0;
					newBoard.board[row-1][column] = temp3;
					newBoard.pathLength = this.pathLength + 1;
					return newBoard;
				}
			case MOVEDOWN:
				
				if (isEmpty(row+1, column) == true) {
					newBoard.parent = this;
					newBoard.op = Operation.MOVEDOWN;
					int temp4 = newBoard.board[row][column];
					newBoard.board[row][column] = 0;
					newBoard.board[row+1][column] = temp4;
					newBoard.pathLength = this.pathLength + 1;
					return newBoard;
				}
		}
		return null;
	}

	@Override
	public PuzzleState flip(int startRow, int startColumn, int endRow, int endColumn) {
		
		PuzzleState newBoard = null;
		
//		SimplePuzzleState newBoard = new SimplePuzzleState();
//		for (int i=0; i < board.length; i++) {
//			for (int j=0; j < board.length; j++) {
//				newBoard.board[i][j] = this.board[i][j];
//			}
//		}
		// make sure the current tile is not empty and the end tile is empty
		if ((isEmpty(startRow, startColumn) == false) && (isEmpty(endRow, endColumn) == true)) {
			if (endRow == startRow - 1) {
				newBoard = this.move(startRow, startColumn, Operation.MOVEUP);
				return newBoard;
			}
			else if (endRow == startRow + 1) {
				newBoard = this.move(startRow, startColumn, Operation.MOVEDOWN);
				return newBoard;
			}
			else if (endColumn == startColumn + 1) {
				newBoard = this.move(startRow, startColumn, Operation.MOVERIGHT);
				return newBoard;
			}
			else {
				newBoard = this.move(startRow, startColumn, Operation.MOVELEFT);
				return newBoard;
			}
		}
		else {
			return null;
		}
	}

	@Override
	public PuzzleState shuffleBoard(int pathLength) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public boolean isEmpty(int row, int column) {
		if ((row < 0) || (row >= this.board.length) || (column < 0) || (column >= this.board.length)) {
			return false;
		}
		else if (this.board[row][column] == 0) {
			return true;
		}
		else {
			return false;
		}
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + Arrays.deepHashCode(board);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		SimplePuzzleState other = (SimplePuzzleState) obj;
		if (!Arrays.deepEquals(board, other.board))
			return false;
		return true;
	}

}
